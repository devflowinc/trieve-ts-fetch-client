"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.6.9
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChunkApi = void 0;
var runtime = require("../runtime");
var index_1 = require("../models/index");
/**
 *
 */
var ChunkApi = /** @class */ (function (_super) {
    __extends(ChunkApi, _super);
    function ChunkApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
     * Create or Upsert Chunk or Chunks
     */
    ChunkApi.prototype.createChunkRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling createChunk().');
                        }
                        if (requestParameters['createChunkData'] == null) {
                            throw new runtime.RequiredError('createChunkData', 'Required parameter "createChunkData" was null or undefined when calling createChunk().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        headerParameters['Content-Type'] = 'application/json';
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk",
                            method: 'POST',
                            headers: headerParameters,
                            query: queryParameters,
                            body: (0, index_1.CreateChunkDataToJSON)(requestParameters['createChunkData']),
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.JSONApiResponse(response, function (jsonValue) { return (0, index_1.ReturnQueuedChunkFromJSON)(jsonValue); })];
                }
            });
        });
    };
    /**
     * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
     * Create or Upsert Chunk or Chunks
     */
    ChunkApi.prototype.createChunk = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createChunkRaw(requestParameters, initOverrides)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.value()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
     * Generate suggested queries
     */
    ChunkApi.prototype.createSuggestedQueriesHandlerRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling createSuggestedQueriesHandler().');
                        }
                        if (requestParameters['suggestedQueriesRequest'] == null) {
                            throw new runtime.RequiredError('suggestedQueriesRequest', 'Required parameter "suggestedQueriesRequest" was null or undefined when calling createSuggestedQueriesHandler().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        headerParameters['Content-Type'] = 'application/json';
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk/gen_suggestions",
                            method: 'POST',
                            headers: headerParameters,
                            query: queryParameters,
                            body: (0, index_1.SuggestedQueriesRequestToJSON)(requestParameters['suggestedQueriesRequest']),
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.JSONApiResponse(response, function (jsonValue) { return (0, index_1.SuggestedQueriesResponseFromJSON)(jsonValue); })];
                }
            });
        });
    };
    /**
     * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
     * Generate suggested queries
     */
    ChunkApi.prototype.createSuggestedQueriesHandler = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createSuggestedQueriesHandlerRaw(requestParameters, initOverrides)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.value()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * Delete Chunk
     */
    ChunkApi.prototype.deleteChunkRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling deleteChunk().');
                        }
                        if (requestParameters['chunkId'] == null) {
                            throw new runtime.RequiredError('chunkId', 'Required parameter "chunkId" was null or undefined when calling deleteChunk().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk/{chunk_id}".replace("{".concat("chunk_id", "}"), encodeURIComponent(String(requestParameters['chunkId']))),
                            method: 'DELETE',
                            headers: headerParameters,
                            query: queryParameters,
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.VoidApiResponse(response)];
                }
            });
        });
    };
    /**
     * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * Delete Chunk
     */
    ChunkApi.prototype.deleteChunk = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.deleteChunkRaw(requestParameters, initOverrides)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * Delete Chunk By Tracking Id
     */
    ChunkApi.prototype.deleteChunkByTrackingIdRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling deleteChunkByTrackingId().');
                        }
                        if (requestParameters['trackingId'] == null) {
                            throw new runtime.RequiredError('trackingId', 'Required parameter "trackingId" was null or undefined when calling deleteChunkByTrackingId().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk/tracking_id/{tracking_id}".replace("{".concat("tracking_id", "}"), encodeURIComponent(String(requestParameters['trackingId']))),
                            method: 'DELETE',
                            headers: headerParameters,
                            query: queryParameters,
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.VoidApiResponse(response)];
                }
            });
        });
    };
    /**
     * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * Delete Chunk By Tracking Id
     */
    ChunkApi.prototype.deleteChunkByTrackingId = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.deleteChunkByTrackingIdRaw(requestParameters, initOverrides)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.trieve.ai.
     * RAG on Specified Chunks
     */
    ChunkApi.prototype.generateOffChunksRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling generateOffChunks().');
                        }
                        if (requestParameters['generateChunksRequest'] == null) {
                            throw new runtime.RequiredError('generateChunksRequest', 'Required parameter "generateChunksRequest" was null or undefined when calling generateOffChunks().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        headerParameters['Content-Type'] = 'application/json';
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk/generate",
                            method: 'POST',
                            headers: headerParameters,
                            query: queryParameters,
                            body: (0, index_1.GenerateChunksRequestToJSON)(requestParameters['generateChunksRequest']),
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        if (this.isJsonMime(response.headers.get('content-type'))) {
                            return [2 /*return*/, new runtime.JSONApiResponse(response)];
                        }
                        else {
                            return [2 /*return*/, new runtime.TextApiResponse(response)];
                        }
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.trieve.ai.
     * RAG on Specified Chunks
     */
    ChunkApi.prototype.generateOffChunks = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.generateOffChunksRaw(requestParameters, initOverrides)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.value()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Get Chunk By Id  Get a singular chunk by id.
     * Get Chunk By Id
     */
    ChunkApi.prototype.getChunkByIdRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling getChunkById().');
                        }
                        if (requestParameters['chunkId'] == null) {
                            throw new runtime.RequiredError('chunkId', 'Required parameter "chunkId" was null or undefined when calling getChunkById().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk/{chunk_id}".replace("{".concat("chunk_id", "}"), encodeURIComponent(String(requestParameters['chunkId']))),
                            method: 'GET',
                            headers: headerParameters,
                            query: queryParameters,
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.JSONApiResponse(response, function (jsonValue) { return (0, index_1.ChunkMetadataFromJSON)(jsonValue); })];
                }
            });
        });
    };
    /**
     * Get Chunk By Id  Get a singular chunk by id.
     * Get Chunk By Id
     */
    ChunkApi.prototype.getChunkById = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getChunkByIdRaw(requestParameters, initOverrides)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.value()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     * Get Chunk By Tracking Id
     */
    ChunkApi.prototype.getChunkByTrackingIdRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling getChunkByTrackingId().');
                        }
                        if (requestParameters['trackingId'] == null) {
                            throw new runtime.RequiredError('trackingId', 'Required parameter "trackingId" was null or undefined when calling getChunkByTrackingId().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk/tracking_id/{tracking_id}".replace("{".concat("tracking_id", "}"), encodeURIComponent(String(requestParameters['trackingId']))),
                            method: 'GET',
                            headers: headerParameters,
                            query: queryParameters,
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.JSONApiResponse(response, function (jsonValue) { return (0, index_1.ChunkMetadataFromJSON)(jsonValue); })];
                }
            });
        });
    };
    /**
     * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     * Get Chunk By Tracking Id
     */
    ChunkApi.prototype.getChunkByTrackingId = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getChunkByTrackingIdRaw(requestParameters, initOverrides)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.value()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \"add to playlist\" recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
     * Get Recommended Chunks
     */
    ChunkApi.prototype.getRecommendedChunksRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling getRecommendedChunks().');
                        }
                        if (requestParameters['recommendChunksRequest'] == null) {
                            throw new runtime.RequiredError('recommendChunksRequest', 'Required parameter "recommendChunksRequest" was null or undefined when calling getRecommendedChunks().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        headerParameters['Content-Type'] = 'application/json';
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk/recommend",
                            method: 'POST',
                            headers: headerParameters,
                            query: queryParameters,
                            body: (0, index_1.RecommendChunksRequestToJSON)(requestParameters['recommendChunksRequest']),
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.JSONApiResponse(response, function (jsonValue) { return jsonValue.map(index_1.ChunkMetadataWithScoreFromJSON); })];
                }
            });
        });
    };
    /**
     * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \"add to playlist\" recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
     * Get Recommended Chunks
     */
    ChunkApi.prototype.getRecommendedChunks = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getRecommendedChunksRaw(requestParameters, initOverrides)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.value()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<b><mark>` tags for sub-sentence highlighting.
     * Search
     */
    ChunkApi.prototype.searchChunkRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling searchChunk().');
                        }
                        if (requestParameters['searchChunkData'] == null) {
                            throw new runtime.RequiredError('searchChunkData', 'Required parameter "searchChunkData" was null or undefined when calling searchChunk().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        headerParameters['Content-Type'] = 'application/json';
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk/search",
                            method: 'POST',
                            headers: headerParameters,
                            query: queryParameters,
                            body: (0, index_1.SearchChunkDataToJSON)(requestParameters['searchChunkData']),
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.JSONApiResponse(response, function (jsonValue) { return (0, index_1.SearchChunkQueryResponseBodyFromJSON)(jsonValue); })];
                }
            });
        });
    };
    /**
     * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<b><mark>` tags for sub-sentence highlighting.
     * Search
     */
    ChunkApi.prototype.searchChunk = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.searchChunkRaw(requestParameters, initOverrides)];
                    case 1:
                        response = _a.sent();
                        return [4 /*yield*/, response.value()];
                    case 2: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    /**
     * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
     * Update Chunk
     */
    ChunkApi.prototype.updateChunkRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling updateChunk().');
                        }
                        if (requestParameters['updateChunkData'] == null) {
                            throw new runtime.RequiredError('updateChunkData', 'Required parameter "updateChunkData" was null or undefined when calling updateChunk().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        headerParameters['Content-Type'] = 'application/json';
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk",
                            method: 'PUT',
                            headers: headerParameters,
                            query: queryParameters,
                            body: (0, index_1.UpdateChunkDataToJSON)(requestParameters['updateChunkData']),
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.VoidApiResponse(response)];
                }
            });
        });
    };
    /**
     * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
     * Update Chunk
     */
    ChunkApi.prototype.updateChunk = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.updateChunkRaw(requestParameters, initOverrides)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * Update Chunk By Tracking Id
     * @deprecated
     */
    ChunkApi.prototype.updateChunkByTrackingIdRaw = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            var queryParameters, headerParameters, _a, _b, response;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        if (requestParameters['tRDataset'] == null) {
                            throw new runtime.RequiredError('tRDataset', 'Required parameter "tRDataset" was null or undefined when calling updateChunkByTrackingId().');
                        }
                        if (requestParameters['updateChunkByTrackingIdData'] == null) {
                            throw new runtime.RequiredError('updateChunkByTrackingIdData', 'Required parameter "updateChunkByTrackingIdData" was null or undefined when calling updateChunkByTrackingId().');
                        }
                        queryParameters = {};
                        headerParameters = {};
                        headerParameters['Content-Type'] = 'application/json';
                        if (requestParameters['tRDataset'] != null) {
                            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
                        }
                        if (!(this.configuration && this.configuration.apiKey)) return [3 /*break*/, 2];
                        _a = headerParameters;
                        _b = "Authorization";
                        return [4 /*yield*/, this.configuration.apiKey("Authorization")];
                    case 1:
                        _a[_b] = _c.sent(); // ApiKey authentication
                        _c.label = 2;
                    case 2: return [4 /*yield*/, this.request({
                            path: "/api/chunk/tracking_id/update",
                            method: 'PUT',
                            headers: headerParameters,
                            query: queryParameters,
                            body: (0, index_1.UpdateChunkByTrackingIdDataToJSON)(requestParameters['updateChunkByTrackingIdData']),
                        }, initOverrides)];
                    case 3:
                        response = _c.sent();
                        return [2 /*return*/, new runtime.VoidApiResponse(response)];
                }
            });
        });
    };
    /**
     * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * Update Chunk By Tracking Id
     * @deprecated
     */
    ChunkApi.prototype.updateChunkByTrackingId = function (requestParameters, initOverrides) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.updateChunkByTrackingIdRaw(requestParameters, initOverrides)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return ChunkApi;
}(runtime.BaseAPI));
exports.ChunkApi = ChunkApi;
