/* tslint:disable */
/* eslint-disable */
/**
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.6.9
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AddChunkToGroupData,
  BookmarkData,
  BookmarkGroupResult,
  ChunkGroup,
  CreateChunkGroupData,
  ErrorResponseBody,
  GetGroupsForChunksData,
  GroupData,
  GroupScoreChunk,
  GroupScoreSlimChunks,
  RecommendGroupChunksRequest,
  SearchOverGroupsData,
  SearchOverGroupsResults,
  SearchOverGroupsSlimResults,
  SearchWithinGroupData,
  SearchWithinGroupResults,
  SearchWithinGroupSlimResults,
  UpdateChunkGroupData,
  UpdateGroupByTrackingIDData,
} from '../models/index';
import {
    AddChunkToGroupDataFromJSON,
    AddChunkToGroupDataToJSON,
    BookmarkDataFromJSON,
    BookmarkDataToJSON,
    BookmarkGroupResultFromJSON,
    BookmarkGroupResultToJSON,
    ChunkGroupFromJSON,
    ChunkGroupToJSON,
    CreateChunkGroupDataFromJSON,
    CreateChunkGroupDataToJSON,
    ErrorResponseBodyFromJSON,
    ErrorResponseBodyToJSON,
    GetGroupsForChunksDataFromJSON,
    GetGroupsForChunksDataToJSON,
    GroupDataFromJSON,
    GroupDataToJSON,
    GroupScoreChunkFromJSON,
    GroupScoreChunkToJSON,
    GroupScoreSlimChunksFromJSON,
    GroupScoreSlimChunksToJSON,
    RecommendGroupChunksRequestFromJSON,
    RecommendGroupChunksRequestToJSON,
    SearchOverGroupsDataFromJSON,
    SearchOverGroupsDataToJSON,
    SearchOverGroupsResultsFromJSON,
    SearchOverGroupsResultsToJSON,
    SearchOverGroupsSlimResultsFromJSON,
    SearchOverGroupsSlimResultsToJSON,
    SearchWithinGroupDataFromJSON,
    SearchWithinGroupDataToJSON,
    SearchWithinGroupResultsFromJSON,
    SearchWithinGroupResultsToJSON,
    SearchWithinGroupSlimResultsFromJSON,
    SearchWithinGroupSlimResultsToJSON,
    UpdateChunkGroupDataFromJSON,
    UpdateChunkGroupDataToJSON,
    UpdateGroupByTrackingIDDataFromJSON,
    UpdateGroupByTrackingIDDataToJSON,
} from '../models/index';

export interface AddChunkToGroupRequest {
    tRDataset: string;
    groupId: string;
    addChunkToGroupData: AddChunkToGroupData;
}

export interface AddChunkToGroupByTrackingIdRequest {
    tRDataset: string;
    trackingId: string;
    addChunkToGroupData: AddChunkToGroupData;
}

export interface CreateChunkGroupRequest {
    tRDataset: string;
    createChunkGroupData: CreateChunkGroupData;
}

export interface DeleteChunkGroupRequest {
    tRDataset: string;
    groupId: string;
    deleteChunks: boolean;
}

export interface DeleteGroupByTrackingIdRequest {
    tRDataset: string;
    trackingId: string;
}

export interface GetChunkGroupRequest {
    tRDataset: string;
    groupId: string;
}

export interface GetChunksInGroupRequest {
    tRDataset: string;
    groupId: string;
    page: number | null;
}

export interface GetChunksInGroupByTrackingIdRequest {
    tRDataset: string;
    groupTrackingId: string;
    page: number;
}

export interface GetGroupByTrackingIdRequest {
    tRDataset: string;
    trackingId: string;
}

export interface GetGroupsChunkIsInRequest {
    tRDataset: string;
    getGroupsForChunksData: GetGroupsForChunksData;
}

export interface GetRecommendedGroupsRequest {
    tRDataset: string;
    recommendGroupChunksRequest: RecommendGroupChunksRequest;
}

export interface GetSpecificDatasetChunkGroupsRequest {
    tRDataset: string;
    datasetId: string;
    page: number;
}

export interface RemoveChunkFromGroupRequest {
    tRDataset: string;
    groupId: string;
    createChunkGroupData: CreateChunkGroupData;
}

export interface SearchOverGroupsRequest {
    tRDataset: string;
    searchOverGroupsData: SearchOverGroupsData;
}

export interface SearchWithinGroupRequest {
    tRDataset: string;
    searchWithinGroupData: SearchWithinGroupData;
}

export interface UpdateChunkGroupRequest {
    tRDataset: string;
    updateChunkGroupData: UpdateChunkGroupData;
}

export interface UpdateGroupByTrackingIdRequest {
    tRDataset: string;
    trackingId: string;
    updateGroupByTrackingIDData: UpdateGroupByTrackingIDData;
}

/**
 * 
 */
export class ChunkGroupApi extends runtime.BaseAPI {

    /**
     * Add Chunk to Group  Route to add a chunk to a group.
     * Add Chunk to Group
     */
    async addChunkToGroupRaw(requestParameters: AddChunkToGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling addChunkToGroup().'
            );
        }

        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling addChunkToGroup().'
            );
        }

        if (requestParameters['addChunkToGroupData'] == null) {
            throw new runtime.RequiredError(
                'addChunkToGroupData',
                'Required parameter "addChunkToGroupData" was null or undefined when calling addChunkToGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/chunk/{group_id}`.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters['groupId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddChunkToGroupDataToJSON(requestParameters['addChunkToGroupData']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add Chunk to Group  Route to add a chunk to a group.
     * Add Chunk to Group
     */
    async addChunkToGroup(requestParameters: AddChunkToGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addChunkToGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Add Chunk to Group by Tracking ID  Route to add a chunk to a group by tracking id.
     * Add Chunk to Group by Tracking ID
     * @deprecated
     */
    async addChunkToGroupByTrackingIdRaw(requestParameters: AddChunkToGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling addChunkToGroupByTrackingId().'
            );
        }

        if (requestParameters['trackingId'] == null) {
            throw new runtime.RequiredError(
                'trackingId',
                'Required parameter "trackingId" was null or undefined when calling addChunkToGroupByTrackingId().'
            );
        }

        if (requestParameters['addChunkToGroupData'] == null) {
            throw new runtime.RequiredError(
                'addChunkToGroupData',
                'Required parameter "addChunkToGroupData" was null or undefined when calling addChunkToGroupByTrackingId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/tracking_id/{tracking_id}`.replace(`{${"tracking_id"}}`, encodeURIComponent(String(requestParameters['trackingId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AddChunkToGroupDataToJSON(requestParameters['addChunkToGroupData']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Add Chunk to Group by Tracking ID  Route to add a chunk to a group by tracking id.
     * Add Chunk to Group by Tracking ID
     * @deprecated
     */
    async addChunkToGroupByTrackingId(requestParameters: AddChunkToGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.addChunkToGroupByTrackingIdRaw(requestParameters, initOverrides);
    }

    /**
     * Create Chunk Group  Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail.
     * Create Chunk Group
     */
    async createChunkGroupRaw(requestParameters: CreateChunkGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChunkGroup>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling createChunkGroup().'
            );
        }

        if (requestParameters['createChunkGroupData'] == null) {
            throw new runtime.RequiredError(
                'createChunkGroupData',
                'Required parameter "createChunkGroupData" was null or undefined when calling createChunkGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateChunkGroupDataToJSON(requestParameters['createChunkGroupData']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChunkGroupFromJSON(jsonValue));
    }

    /**
     * Create Chunk Group  Create a new chunk_group. This is a way to group chunks together. If you try to create a chunk_group with the same tracking_id as an existing chunk_group, this operation will fail.
     * Create Chunk Group
     */
    async createChunkGroup(requestParameters: CreateChunkGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChunkGroup> {
        const response = await this.createChunkGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Group  This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group.
     * Delete Group
     */
    async deleteChunkGroupRaw(requestParameters: DeleteChunkGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling deleteChunkGroup().'
            );
        }

        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling deleteChunkGroup().'
            );
        }

        if (requestParameters['deleteChunks'] == null) {
            throw new runtime.RequiredError(
                'deleteChunks',
                'Required parameter "deleteChunks" was null or undefined when calling deleteChunkGroup().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['deleteChunks'] != null) {
            queryParameters['delete_chunks'] = requestParameters['deleteChunks'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/{group_id}`.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters['groupId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Group  This will delete a chunk_group. If you set delete_chunks to true, it will also delete the chunks within the group.
     * Delete Group
     */
    async deleteChunkGroup(requestParameters: DeleteChunkGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteChunkGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Group by Tracking ID  Delete a chunk_group with the given tracking id.
     * Delete Group by Tracking ID
     */
    async deleteGroupByTrackingIdRaw(requestParameters: DeleteGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling deleteGroupByTrackingId().'
            );
        }

        if (requestParameters['trackingId'] == null) {
            throw new runtime.RequiredError(
                'trackingId',
                'Required parameter "trackingId" was null or undefined when calling deleteGroupByTrackingId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/tracking_id/{tracking_id}`.replace(`{${"tracking_id"}}`, encodeURIComponent(String(requestParameters['trackingId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Group by Tracking ID  Delete a chunk_group with the given tracking id.
     * Delete Group by Tracking ID
     */
    async deleteGroupByTrackingId(requestParameters: DeleteGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteGroupByTrackingIdRaw(requestParameters, initOverrides);
    }

    /**
     * Get Group  Fetch the group with the given id. get_group
     * Get Group
     */
    async getChunkGroupRaw(requestParameters: GetChunkGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChunkGroup>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getChunkGroup().'
            );
        }

        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling getChunkGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/{group_id}`.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters['groupId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChunkGroupFromJSON(jsonValue));
    }

    /**
     * Get Group  Fetch the group with the given id. get_group
     * Get Group
     */
    async getChunkGroup(requestParameters: GetChunkGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChunkGroup> {
        const response = await this.getChunkGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Chunks in Group  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
     * Get Chunks in Group
     */
    async getChunksInGroupRaw(requestParameters: GetChunksInGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BookmarkData>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getChunksInGroup().'
            );
        }

        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling getChunksInGroup().'
            );
        }

        if (requestParameters['page'] == null) {
            throw new runtime.RequiredError(
                'page',
                'Required parameter "page" was null or undefined when calling getChunksInGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/{group_id}/{page}`.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters['groupId']))).replace(`{${"page"}}`, encodeURIComponent(String(requestParameters['page']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkDataFromJSON(jsonValue));
    }

    /**
     * Get Chunks in Group  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Page is 1-indexed.
     * Get Chunks in Group
     */
    async getChunksInGroup(requestParameters: GetChunksInGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BookmarkData> {
        const response = await this.getChunksInGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Chunks in Group by Tracking ID  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
     * Get Chunks in Group by Tracking ID
     */
    async getChunksInGroupByTrackingIdRaw(requestParameters: GetChunksInGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BookmarkData>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getChunksInGroupByTrackingId().'
            );
        }

        if (requestParameters['groupTrackingId'] == null) {
            throw new runtime.RequiredError(
                'groupTrackingId',
                'Required parameter "groupTrackingId" was null or undefined when calling getChunksInGroupByTrackingId().'
            );
        }

        if (requestParameters['page'] == null) {
            throw new runtime.RequiredError(
                'page',
                'Required parameter "page" was null or undefined when calling getChunksInGroupByTrackingId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/tracking_id/{group_tracking_id}/{page}`.replace(`{${"group_tracking_id"}}`, encodeURIComponent(String(requestParameters['groupTrackingId']))).replace(`{${"page"}}`, encodeURIComponent(String(requestParameters['page']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkDataFromJSON(jsonValue));
    }

    /**
     * Get Chunks in Group by Tracking ID  Route to get all chunks for a group. The response is paginated, with each page containing 10 chunks. Support for custom page size is coming soon. Page is 1-indexed.
     * Get Chunks in Group by Tracking ID
     */
    async getChunksInGroupByTrackingId(requestParameters: GetChunksInGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BookmarkData> {
        const response = await this.getChunksInGroupByTrackingIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Group by Tracking ID  Fetch the group with the given tracking id. get_group_by_tracking_id
     * Get Group by Tracking ID
     */
    async getGroupByTrackingIdRaw(requestParameters: GetGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChunkGroup>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getGroupByTrackingId().'
            );
        }

        if (requestParameters['trackingId'] == null) {
            throw new runtime.RequiredError(
                'trackingId',
                'Required parameter "trackingId" was null or undefined when calling getGroupByTrackingId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/tracking_id/{tracking_id}`.replace(`{${"tracking_id"}}`, encodeURIComponent(String(requestParameters['trackingId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChunkGroupFromJSON(jsonValue));
    }

    /**
     * Get Group by Tracking ID  Fetch the group with the given tracking id. get_group_by_tracking_id
     * Get Group by Tracking ID
     */
    async getGroupByTrackingId(requestParameters: GetGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChunkGroup> {
        const response = await this.getGroupByTrackingIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Groups for Chunks  Route to get the groups that a chunk is in.
     * Get Groups for Chunks
     */
    async getGroupsChunkIsInRaw(requestParameters: GetGroupsChunkIsInRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BookmarkGroupResult>>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getGroupsChunkIsIn().'
            );
        }

        if (requestParameters['getGroupsForChunksData'] == null) {
            throw new runtime.RequiredError(
                'getGroupsForChunksData',
                'Required parameter "getGroupsForChunksData" was null or undefined when calling getGroupsChunkIsIn().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/chunks`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetGroupsForChunksDataToJSON(requestParameters['getGroupsForChunksData']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BookmarkGroupResultFromJSON));
    }

    /**
     * Get Groups for Chunks  Route to get the groups that a chunk is in.
     * Get Groups for Chunks
     */
    async getGroupsChunkIsIn(requestParameters: GetGroupsChunkIsInRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BookmarkGroupResult>> {
        const response = await this.getGroupsChunkIsInRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Recommended Groups  Route to get recommended groups. This route will return groups which are similar to the groups in the request body.
     * Get Recommended Groups
     */
    async getRecommendedGroupsRaw(requestParameters: GetRecommendedGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<GroupScoreChunk>>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getRecommendedGroups().'
            );
        }

        if (requestParameters['recommendGroupChunksRequest'] == null) {
            throw new runtime.RequiredError(
                'recommendGroupChunksRequest',
                'Required parameter "recommendGroupChunksRequest" was null or undefined when calling getRecommendedGroups().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/recommend`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecommendGroupChunksRequestToJSON(requestParameters['recommendGroupChunksRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GroupScoreChunkFromJSON));
    }

    /**
     * Get Recommended Groups  Route to get recommended groups. This route will return groups which are similar to the groups in the request body.
     * Get Recommended Groups
     */
    async getRecommendedGroups(requestParameters: GetRecommendedGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<GroupScoreChunk>> {
        const response = await this.getRecommendedGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Groups for Dataset  Fetch the groups which belong to a dataset specified by its id.
     * Get Groups for Dataset
     */
    async getSpecificDatasetChunkGroupsRaw(requestParameters: GetSpecificDatasetChunkGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GroupData>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getSpecificDatasetChunkGroups().'
            );
        }

        if (requestParameters['datasetId'] == null) {
            throw new runtime.RequiredError(
                'datasetId',
                'Required parameter "datasetId" was null or undefined when calling getSpecificDatasetChunkGroups().'
            );
        }

        if (requestParameters['page'] == null) {
            throw new runtime.RequiredError(
                'page',
                'Required parameter "page" was null or undefined when calling getSpecificDatasetChunkGroups().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/dataset/groups/{dataset_id}/{page}`.replace(`{${"dataset_id"}}`, encodeURIComponent(String(requestParameters['datasetId']))).replace(`{${"page"}}`, encodeURIComponent(String(requestParameters['page']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupDataFromJSON(jsonValue));
    }

    /**
     * Get Groups for Dataset  Fetch the groups which belong to a dataset specified by its id.
     * Get Groups for Dataset
     */
    async getSpecificDatasetChunkGroups(requestParameters: GetSpecificDatasetChunkGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GroupData> {
        const response = await this.getSpecificDatasetChunkGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Remove Chunk from Group  Route to remove a chunk from a group.
     * Remove Chunk from Group
     */
    async removeChunkFromGroupRaw(requestParameters: RemoveChunkFromGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling removeChunkFromGroup().'
            );
        }

        if (requestParameters['groupId'] == null) {
            throw new runtime.RequiredError(
                'groupId',
                'Required parameter "groupId" was null or undefined when calling removeChunkFromGroup().'
            );
        }

        if (requestParameters['createChunkGroupData'] == null) {
            throw new runtime.RequiredError(
                'createChunkGroupData',
                'Required parameter "createChunkGroupData" was null or undefined when calling removeChunkFromGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/chunk/{group_id}`.replace(`{${"group_id"}}`, encodeURIComponent(String(requestParameters['groupId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: CreateChunkGroupDataToJSON(requestParameters['createChunkGroupData']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Remove Chunk from Group  Route to remove a chunk from a group.
     * Remove Chunk from Group
     */
    async removeChunkFromGroup(requestParameters: RemoveChunkFromGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.removeChunkFromGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Search Over Groups  This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
     * Search Over Groups
     */
    async searchOverGroupsRaw(requestParameters: SearchOverGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchOverGroupsResults>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling searchOverGroups().'
            );
        }

        if (requestParameters['searchOverGroupsData'] == null) {
            throw new runtime.RequiredError(
                'searchOverGroupsData',
                'Required parameter "searchOverGroupsData" was null or undefined when calling searchOverGroups().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/group_oriented_search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SearchOverGroupsDataToJSON(requestParameters['searchOverGroupsData']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchOverGroupsResultsFromJSON(jsonValue));
    }

    /**
     * Search Over Groups  This route allows you to get groups as results instead of chunks. Each group returned will have the matching chunks sorted by similarity within the group. This is useful for when you want to get groups of chunks which are similar to the search query. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large. Compatible with semantic, fulltext, or hybrid search modes.
     * Search Over Groups
     */
    async searchOverGroups(requestParameters: SearchOverGroupsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchOverGroupsResults> {
        const response = await this.searchOverGroupsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search Within Group  This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
     * Search Within Group
     */
    async searchWithinGroupRaw(requestParameters: SearchWithinGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchWithinGroupResults>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling searchWithinGroup().'
            );
        }

        if (requestParameters['searchWithinGroupData'] == null) {
            throw new runtime.RequiredError(
                'searchWithinGroupData',
                'Required parameter "searchWithinGroupData" was null or undefined when calling searchWithinGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SearchWithinGroupDataToJSON(requestParameters['searchWithinGroupData']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchWithinGroupResultsFromJSON(jsonValue));
    }

    /**
     * Search Within Group  This route allows you to search only within a group. This is useful for when you only want search results to contain chunks which are members of a specific group. If choosing hybrid search, the results will be re-ranked using BAAI/bge-reranker-large.
     * Search Within Group
     */
    async searchWithinGroup(requestParameters: SearchWithinGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchWithinGroupResults> {
        const response = await this.searchWithinGroupRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Group  Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail.
     * Update Group
     */
    async updateChunkGroupRaw(requestParameters: UpdateChunkGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling updateChunkGroup().'
            );
        }

        if (requestParameters['updateChunkGroupData'] == null) {
            throw new runtime.RequiredError(
                'updateChunkGroupData',
                'Required parameter "updateChunkGroupData" was null or undefined when calling updateChunkGroup().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateChunkGroupDataToJSON(requestParameters['updateChunkGroupData']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update Group  Update a chunk_group. If you try to change the tracking_id to one that already exists, this operation will fail.
     * Update Group
     */
    async updateChunkGroup(requestParameters: UpdateChunkGroupRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateChunkGroupRaw(requestParameters, initOverrides);
    }

    /**
     * Update Group by Tracking ID  Update a chunk_group with the given tracking id.
     * Update Group by Tracking ID
     * @deprecated
     */
    async updateGroupByTrackingIdRaw(requestParameters: UpdateGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling updateGroupByTrackingId().'
            );
        }

        if (requestParameters['trackingId'] == null) {
            throw new runtime.RequiredError(
                'trackingId',
                'Required parameter "trackingId" was null or undefined when calling updateGroupByTrackingId().'
            );
        }

        if (requestParameters['updateGroupByTrackingIDData'] == null) {
            throw new runtime.RequiredError(
                'updateGroupByTrackingIDData',
                'Required parameter "updateGroupByTrackingIDData" was null or undefined when calling updateGroupByTrackingId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk_group/tracking_id/{tracking_id}`.replace(`{${"tracking_id"}}`, encodeURIComponent(String(requestParameters['trackingId']))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateGroupByTrackingIDDataToJSON(requestParameters['updateGroupByTrackingIDData']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update Group by Tracking ID  Update a chunk_group with the given tracking id.
     * Update Group by Tracking ID
     * @deprecated
     */
    async updateGroupByTrackingId(requestParameters: UpdateGroupByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateGroupByTrackingIdRaw(requestParameters, initOverrides);
    }

}
