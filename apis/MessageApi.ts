/* tslint:disable */
/* eslint-disable */
/**
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.6.9
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateMessageData,
  EditMessageData,
  ErrorResponseBody,
  Message,
  RegenerateMessageData,
} from '../models/index';
import {
    CreateMessageDataFromJSON,
    CreateMessageDataToJSON,
    EditMessageDataFromJSON,
    EditMessageDataToJSON,
    ErrorResponseBodyFromJSON,
    ErrorResponseBodyToJSON,
    MessageFromJSON,
    MessageToJSON,
    RegenerateMessageDataFromJSON,
    RegenerateMessageDataToJSON,
} from '../models/index';

export interface CreateMessageCompletionHandlerRequest {
    tRDataset: string;
    createMessageData: CreateMessageData;
}

export interface EditMessageHandlerRequest {
    tRDataset: string;
    editMessageData: EditMessageData;
}

export interface GetAllTopicMessagesRequest {
    tRDataset: string;
    messagesTopicId: string;
}

export interface RegenerateMessageHandlerRequest {
    tRDataset: string;
    regenerateMessageData: RegenerateMessageData;
}

/**
 * 
 */
export class MessageApi extends runtime.BaseAPI {

    /**
     * Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * Create a message
     */
    async createMessageCompletionHandlerRaw(requestParameters: CreateMessageCompletionHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling createMessageCompletionHandler().'
            );
        }

        if (requestParameters['createMessageData'] == null) {
            throw new runtime.RequiredError(
                'createMessageData',
                'Required parameter "createMessageData" was null or undefined when calling createMessageCompletionHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/message`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateMessageDataToJSON(requestParameters['createMessageData']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Create a message  Create a message. Messages are attached to topics in order to coordinate memory of gen-AI chat sessions. We are considering refactoring this resource of the API soon. Currently, you can only send user messages. If the topic is a RAG topic then the response will include Chunks first on the stream. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * Create a message
     */
    async createMessageCompletionHandler(requestParameters: CreateMessageCompletionHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.createMessageCompletionHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edit a message  Edit a message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * Edit a message
     */
    async editMessageHandlerRaw(requestParameters: EditMessageHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling editMessageHandler().'
            );
        }

        if (requestParameters['editMessageData'] == null) {
            throw new runtime.RequiredError(
                'editMessageData',
                'Required parameter "editMessageData" was null or undefined when calling editMessageHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/message`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: EditMessageDataToJSON(requestParameters['editMessageData']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Edit a message  Edit a message which exists within the topic\'s chat history. This will delete the message and replace it with a new message. The new message will be generated by the AI based on the new content provided in the request body. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * Edit a message
     */
    async editMessageHandler(requestParameters: EditMessageHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.editMessageHandlerRaw(requestParameters, initOverrides);
    }

    /**
     * Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * Get all messages for a given topic
     */
    async getAllTopicMessagesRaw(requestParameters: GetAllTopicMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Message>>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getAllTopicMessages().'
            );
        }

        if (requestParameters['messagesTopicId'] == null) {
            throw new runtime.RequiredError(
                'messagesTopicId',
                'Required parameter "messagesTopicId" was null or undefined when calling getAllTopicMessages().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/messages/{messages_topic_id}`.replace(`{${"messages_topic_id"}}`, encodeURIComponent(String(requestParameters['messagesTopicId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MessageFromJSON));
    }

    /**
     * Get all messages for a given topic  Get all messages for a given topic. If the topic is a RAG topic then the response will include Chunks first on each message. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * Get all messages for a given topic
     */
    async getAllTopicMessages(requestParameters: GetAllTopicMessagesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Message>> {
        const response = await this.getAllTopicMessagesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * Regenerate message
     */
    async regenerateMessageHandlerRaw(requestParameters: RegenerateMessageHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling regenerateMessageHandler().'
            );
        }

        if (requestParameters['regenerateMessageData'] == null) {
            throw new runtime.RequiredError(
                'regenerateMessageData',
                'Required parameter "regenerateMessageData" was null or undefined when calling regenerateMessageHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/message`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: RegenerateMessageDataToJSON(requestParameters['regenerateMessageData']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Regenerate message  Regenerate the assistant response to the last user message of a topic. This will delete the last message and replace it with a new message. The response will include Chunks first on the stream if the topic is using RAG. The structure will look like `[chunks]||mesage`. See docs.trieve.ai for more information.
     * Regenerate message
     */
    async regenerateMessageHandler(requestParameters: RegenerateMessageHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.regenerateMessageHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
