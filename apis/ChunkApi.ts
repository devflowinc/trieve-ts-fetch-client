/* tslint:disable */
/* eslint-disable */
/**
 * Trieve API
 * Trieve OpenAPI Specification. This document describes all of the operations available through the Trieve API.
 *
 * The version of the OpenAPI document: 0.6.9
 * Contact: developers@trieve.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ChunkMetadata,
  ChunkMetadataWithScore,
  CreateChunkData,
  ErrorResponseBody,
  GenerateChunksRequest,
  RecommendChunksRequest,
  ReturnQueuedChunk,
  SearchChunkData,
  SearchChunkQueryResponseBody,
  SearchSlimChunkQueryResponseBody,
  SlimChunkMetadataWithScore,
  SuggestedQueriesRequest,
  SuggestedQueriesResponse,
  UpdateChunkByTrackingIdData,
  UpdateChunkData,
} from '../models/index';
import {
    ChunkMetadataFromJSON,
    ChunkMetadataToJSON,
    ChunkMetadataWithScoreFromJSON,
    ChunkMetadataWithScoreToJSON,
    CreateChunkDataFromJSON,
    CreateChunkDataToJSON,
    ErrorResponseBodyFromJSON,
    ErrorResponseBodyToJSON,
    GenerateChunksRequestFromJSON,
    GenerateChunksRequestToJSON,
    RecommendChunksRequestFromJSON,
    RecommendChunksRequestToJSON,
    ReturnQueuedChunkFromJSON,
    ReturnQueuedChunkToJSON,
    SearchChunkDataFromJSON,
    SearchChunkDataToJSON,
    SearchChunkQueryResponseBodyFromJSON,
    SearchChunkQueryResponseBodyToJSON,
    SearchSlimChunkQueryResponseBodyFromJSON,
    SearchSlimChunkQueryResponseBodyToJSON,
    SlimChunkMetadataWithScoreFromJSON,
    SlimChunkMetadataWithScoreToJSON,
    SuggestedQueriesRequestFromJSON,
    SuggestedQueriesRequestToJSON,
    SuggestedQueriesResponseFromJSON,
    SuggestedQueriesResponseToJSON,
    UpdateChunkByTrackingIdDataFromJSON,
    UpdateChunkByTrackingIdDataToJSON,
    UpdateChunkDataFromJSON,
    UpdateChunkDataToJSON,
} from '../models/index';

export interface CreateChunkRequest {
    tRDataset: string;
    createChunkData: CreateChunkData;
}

export interface CreateSuggestedQueriesHandlerRequest {
    tRDataset: string;
    suggestedQueriesRequest: SuggestedQueriesRequest;
}

export interface DeleteChunkRequest {
    tRDataset: string;
    chunkId: string;
}

export interface DeleteChunkByTrackingIdRequest {
    tRDataset: string;
    trackingId: string;
}

export interface GenerateOffChunksRequest {
    tRDataset: string;
    generateChunksRequest: GenerateChunksRequest;
}

export interface GetChunkByIdRequest {
    tRDataset: string;
    chunkId: string;
}

export interface GetChunkByTrackingIdRequest {
    tRDataset: string;
    trackingId: string;
}

export interface GetRecommendedChunksRequest {
    tRDataset: string;
    recommendChunksRequest: RecommendChunksRequest;
}

export interface SearchChunkRequest {
    tRDataset: string;
    searchChunkData: SearchChunkData;
}

export interface UpdateChunkRequest {
    tRDataset: string;
    updateChunkData: UpdateChunkData;
}

export interface UpdateChunkByTrackingIdRequest {
    tRDataset: string;
    updateChunkByTrackingIdData: UpdateChunkByTrackingIdData;
}

/**
 * 
 */
export class ChunkApi extends runtime.BaseAPI {

    /**
     * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
     * Create or Upsert Chunk or Chunks
     */
    async createChunkRaw(requestParameters: CreateChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReturnQueuedChunk>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling createChunk().'
            );
        }

        if (requestParameters['createChunkData'] == null) {
            throw new runtime.RequiredError(
                'createChunkData',
                'Required parameter "createChunkData" was null or undefined when calling createChunk().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateChunkDataToJSON(requestParameters['createChunkData']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReturnQueuedChunkFromJSON(jsonValue));
    }

    /**
     * Create or Upsert Chunk or Chunks  Create a new chunk. If the chunk has the same tracking_id as an existing chunk, the request will fail. Once a chunk is created, it can be searched for using the search endpoint.
     * Create or Upsert Chunk or Chunks
     */
    async createChunk(requestParameters: CreateChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReturnQueuedChunk> {
        const response = await this.createChunkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
     * Generate suggested queries
     */
    async createSuggestedQueriesHandlerRaw(requestParameters: CreateSuggestedQueriesHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuggestedQueriesResponse>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling createSuggestedQueriesHandler().'
            );
        }

        if (requestParameters['suggestedQueriesRequest'] == null) {
            throw new runtime.RequiredError(
                'suggestedQueriesRequest',
                'Required parameter "suggestedQueriesRequest" was null or undefined when calling createSuggestedQueriesHandler().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk/gen_suggestions`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SuggestedQueriesRequestToJSON(requestParameters['suggestedQueriesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuggestedQueriesResponseFromJSON(jsonValue));
    }

    /**
     * Generate suggested queries  This endpoint will generate 3 suggested queries based off the query provided in the request body and return them as a JSON object.
     * Generate suggested queries
     */
    async createSuggestedQueriesHandler(requestParameters: CreateSuggestedQueriesHandlerRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuggestedQueriesResponse> {
        const response = await this.createSuggestedQueriesHandlerRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * Delete Chunk
     */
    async deleteChunkRaw(requestParameters: DeleteChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling deleteChunk().'
            );
        }

        if (requestParameters['chunkId'] == null) {
            throw new runtime.RequiredError(
                'chunkId',
                'Required parameter "chunkId" was null or undefined when calling deleteChunk().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk/{chunk_id}`.replace(`{${"chunk_id"}}`, encodeURIComponent(String(requestParameters['chunkId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Chunk  Delete a chunk by its id. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * Delete Chunk
     */
    async deleteChunk(requestParameters: DeleteChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteChunkRaw(requestParameters, initOverrides);
    }

    /**
     * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * Delete Chunk By Tracking Id
     */
    async deleteChunkByTrackingIdRaw(requestParameters: DeleteChunkByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling deleteChunkByTrackingId().'
            );
        }

        if (requestParameters['trackingId'] == null) {
            throw new runtime.RequiredError(
                'trackingId',
                'Required parameter "trackingId" was null or undefined when calling deleteChunkByTrackingId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk/tracking_id/{tracking_id}`.replace(`{${"tracking_id"}}`, encodeURIComponent(String(requestParameters['trackingId']))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete Chunk By Tracking Id  Delete a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk. If deleting a root chunk which has a collision, the most recently created collision will become a new root chunk.
     * Delete Chunk By Tracking Id
     */
    async deleteChunkByTrackingId(requestParameters: DeleteChunkByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteChunkByTrackingIdRaw(requestParameters, initOverrides);
    }

    /**
     * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.trieve.ai.
     * RAG on Specified Chunks
     */
    async generateOffChunksRaw(requestParameters: GenerateOffChunksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling generateOffChunks().'
            );
        }

        if (requestParameters['generateChunksRequest'] == null) {
            throw new runtime.RequiredError(
                'generateChunksRequest',
                'Required parameter "generateChunksRequest" was null or undefined when calling generateOffChunks().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk/generate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GenerateChunksRequestToJSON(requestParameters['generateChunksRequest']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * RAG on Specified Chunks  This endpoint exists as an alternative to the topic+message concept where our API handles chat memory. With this endpoint, the user is responsible for providing the context window and the prompt. See more in the \"search before generate\" page at docs.trieve.ai.
     * RAG on Specified Chunks
     */
    async generateOffChunks(requestParameters: GenerateOffChunksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.generateOffChunksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Chunk By Id  Get a singular chunk by id.
     * Get Chunk By Id
     */
    async getChunkByIdRaw(requestParameters: GetChunkByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChunkMetadata>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getChunkById().'
            );
        }

        if (requestParameters['chunkId'] == null) {
            throw new runtime.RequiredError(
                'chunkId',
                'Required parameter "chunkId" was null or undefined when calling getChunkById().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk/{chunk_id}`.replace(`{${"chunk_id"}}`, encodeURIComponent(String(requestParameters['chunkId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChunkMetadataFromJSON(jsonValue));
    }

    /**
     * Get Chunk By Id  Get a singular chunk by id.
     * Get Chunk By Id
     */
    async getChunkById(requestParameters: GetChunkByIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChunkMetadata> {
        const response = await this.getChunkByIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     * Get Chunk By Tracking Id
     */
    async getChunkByTrackingIdRaw(requestParameters: GetChunkByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChunkMetadata>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getChunkByTrackingId().'
            );
        }

        if (requestParameters['trackingId'] == null) {
            throw new runtime.RequiredError(
                'trackingId',
                'Required parameter "trackingId" was null or undefined when calling getChunkByTrackingId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk/tracking_id/{tracking_id}`.replace(`{${"tracking_id"}}`, encodeURIComponent(String(requestParameters['trackingId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChunkMetadataFromJSON(jsonValue));
    }

    /**
     * Get Chunk By Tracking Id  Get a singular chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use your own id as the primary reference for a chunk.
     * Get Chunk By Tracking Id
     */
    async getChunkByTrackingId(requestParameters: GetChunkByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChunkMetadata> {
        const response = await this.getChunkByTrackingIdRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \"add to playlist\" recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
     * Get Recommended Chunks
     */
    async getRecommendedChunksRaw(requestParameters: GetRecommendedChunksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ChunkMetadataWithScore>>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling getRecommendedChunks().'
            );
        }

        if (requestParameters['recommendChunksRequest'] == null) {
            throw new runtime.RequiredError(
                'recommendChunksRequest',
                'Required parameter "recommendChunksRequest" was null or undefined when calling getRecommendedChunks().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk/recommend`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecommendChunksRequestToJSON(requestParameters['recommendChunksRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ChunkMetadataWithScoreFromJSON));
    }

    /**
     * Get Recommended Chunks  Get recommendations of chunks similar to the chunks in the request. Think about this as a feature similar to the \"add to playlist\" recommendation feature on Spotify. This request pairs especially well with our groups endpoint.
     * Get Recommended Chunks
     */
    async getRecommendedChunks(requestParameters: GetRecommendedChunksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ChunkMetadataWithScore>> {
        const response = await this.getRecommendedChunksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<b><mark>` tags for sub-sentence highlighting.
     * Search
     */
    async searchChunkRaw(requestParameters: SearchChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchChunkQueryResponseBody>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling searchChunk().'
            );
        }

        if (requestParameters['searchChunkData'] == null) {
            throw new runtime.RequiredError(
                'searchChunkData',
                'Required parameter "searchChunkData" was null or undefined when calling searchChunk().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk/search`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SearchChunkDataToJSON(requestParameters['searchChunkData']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchChunkQueryResponseBodyFromJSON(jsonValue));
    }

    /**
     * Search  This route provides the primary search functionality for the API. It can be used to search for chunks by semantic similarity, full-text similarity, or a combination of both. Results\' `chunk_html` values will be modified with `<b><mark>` tags for sub-sentence highlighting.
     * Search
     */
    async searchChunk(requestParameters: SearchChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchChunkQueryResponseBody> {
        const response = await this.searchChunkRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
     * Update Chunk
     */
    async updateChunkRaw(requestParameters: UpdateChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling updateChunk().'
            );
        }

        if (requestParameters['updateChunkData'] == null) {
            throw new runtime.RequiredError(
                'updateChunkData',
                'Required parameter "updateChunkData" was null or undefined when calling updateChunk().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateChunkDataToJSON(requestParameters['updateChunkData']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update Chunk  Update a chunk. If you try to change the tracking_id of the chunk to have the same tracking_id as an existing chunk, the request will fail.
     * Update Chunk
     */
    async updateChunk(requestParameters: UpdateChunkRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateChunkRaw(requestParameters, initOverrides);
    }

    /**
     * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * Update Chunk By Tracking Id
     * @deprecated
     */
    async updateChunkByTrackingIdRaw(requestParameters: UpdateChunkByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['tRDataset'] == null) {
            throw new runtime.RequiredError(
                'tRDataset',
                'Required parameter "tRDataset" was null or undefined when calling updateChunkByTrackingId().'
            );
        }

        if (requestParameters['updateChunkByTrackingIdData'] == null) {
            throw new runtime.RequiredError(
                'updateChunkByTrackingIdData',
                'Required parameter "updateChunkByTrackingIdData" was null or undefined when calling updateChunkByTrackingId().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['tRDataset'] != null) {
            headerParameters['TR-Dataset'] = String(requestParameters['tRDataset']);
        }

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = await this.configuration.apiKey("Authorization"); // ApiKey authentication
        }

        const response = await this.request({
            path: `/api/chunk/tracking_id/update`,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UpdateChunkByTrackingIdDataToJSON(requestParameters['updateChunkByTrackingIdData']),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Update Chunk By Tracking Id  Update a chunk by tracking_id. This is useful for when you are coordinating with an external system and want to use the tracking_id to identify the chunk.
     * Update Chunk By Tracking Id
     * @deprecated
     */
    async updateChunkByTrackingId(requestParameters: UpdateChunkByTrackingIdRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.updateChunkByTrackingIdRaw(requestParameters, initOverrides);
    }

}
